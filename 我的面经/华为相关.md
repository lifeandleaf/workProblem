### 手撕string类

[string类实现](./string.cpp)

### C++的define和const的区别，define的宏定义存放在那里

(1) 编译器处理方式不同  
define宏是在预处理阶段展开。    
const常量是编译运行阶段使用。   

(2) 类型和安全检查不同  
define宏没有类型，不做任何类型检查，仅仅是展开。    
const常量有具体的类型，在编译阶段会执行类型检查。   

(3) 存储方式不同    
define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。    
const常量会在内存中分配(可以是堆中也可以是栈中)。   

(4)const可以节省空间，避免不必要的内存分配      
const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而 #define定义的常量在内存中有若干个拷贝。

(5) 提高了效率  
编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高

### C++内存泄漏有哪些经典场景，如何避免？
1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数
2. 没有正确地清除嵌套的对象指针
3. 在释放对象数组时在delete中没有使用方括号(delete [])
4. 指向对象的指针数组不等同于对象数组   
对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间。指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。也就是说，数组的基本类型是指向对象的指针,此时，是用delete 还是delete [](array delete),并不重要，关键是指针并没有析构函数，必须用户自己调用delete语句。
5. 缺少拷贝构造函数
如果没有定义拷贝构造函数，系统根据自动生成的拷贝构造函数进行拷贝工作（浅拷贝），如果类内包含指针，那么两个类指向同一片内存，造成内存泄漏。
6. 缺少重载赋值运算符（理由类似上一条）
7. 返回野指针
8. 没有将基类的析构函数定义为虚函数

### STL相关vector，list

### B树和B+树

### 进程调度算法

### 函数局部变量、全局变量放在哪里，内存分配是在什么时候完成的

局部变量在栈空间上，全局变量存放在静态存储区，局部变量也可以在堆上动态分配，但是使用完之后记得将对空间释放。

局部变量在栈空间上，内存分配发生在定义时。全局变量的内存分配发生在程序开始执行时，程序执行完毕才释放静态存储区。

### 多线程通信的手段

共享内存、消息传递、管道流

### 进程间通讯手段

管道、命名管道、消息队列、共享存储、信号量、套接字、信号

### C++中常见的几类锁

互斥锁、信号量、条件锁、自旋锁、读写锁、递归锁

**互斥锁**：

互斥锁用于控制多个线程对它们之间共享资源互斥访问的一个信号量。也就是说为了避免多个线程在某一时刻同时操作一个共享资源。

**信号量**：

通过信号量也可以实现互斥锁的功能，不过比互斥锁的功能更加强大。在多线程环境下使用，可以用来保证两个或多个关键代码段不被并发调用。当sem_init初始化一个信号量，pshared=0、value=1的时候，即可实现互斥锁的功能。

可以分为两类:

二值信号量：信号量的值只有0和1，这和互斥量很类似，若资源被锁住，信号量的值为0，若资源可用，则信号量的值为1；

计数信号量：信号量的值在0到一个大于1的限制值之间，该计数表示可用的资源的个数。

**条件锁**：

条件锁就是所谓的条件变量，当某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态，一旦条件满足则以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见的就是在线程池中，初始情况下因为没有任务使得任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒该线程来处理这个任务。

**自旋锁**：

当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -> 等待的机制被称为自旋锁。

**读写锁**：

读写锁，又称为多读单写锁，共享互斥锁，以下简称RW lock。读写锁用来解决读写操作并发的问题。多个线程可以并行读取数据，但只能独占式地写或修改数据。

**递归锁**：

递归锁也称为可重入互斥锁，是互斥锁的一种，同一线程对其多次加锁不会产生死锁。递归锁会使用引用计数机制，以便可以从同一线程多次加锁、解锁，当加锁、解锁次数相等时，锁才可以被其他线程获取。

### 内存对齐

```cpp
#include<stdio.h>

struct{
    int x;
    char y;
}Test;
```
理论上，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。

**为什么要内存对齐**

- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
- 假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。
- 现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。

**内存对齐规则**

- 基本类型的对齐值就是其sizeof值;
- 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行;
- 结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行；

### new和malloc的区别

1. 属性上的区别：
new/delete是c++关键字，使用需要编译器支持
malloc/free是库函数，使用需要对应的头文件支持

2. 使用上的区别：
malloc申请空间需要显式的填入申请内存的大小
new无需显式填入申请的内存的大小，new会根据new的类型分配内存。

3. 内存位置的区别：
new此操作符分配的内存空间是在自由存储区
malloc申请的内存是在堆空间。
自由存储区是C++中动态分配和释放对象的一个概念，一般直接用堆空间来实现。

4. 返回类型的区别：
new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。所以在C++程序中使用new会比malloc安全可靠。
malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是都分配成功
new内存分配失败时，会抛出bac_alloc异常，他不会返回NULL，分配失败时如果不捕捉异常，那么程序就会异常退出，我们可以通过异常捕捉的方式获取该异常。

5. 定义对象系统调度过程的区别：
使用new操作符来分配对象内存时会经历三个步骤：调用operator new函数分配一块足够的内存空间（默认底层使用malloc实现）以便存储特定类型的对象；编译器运行相应的构造函数以构造对象，并为其传入初值；对象构造完成后，返回一个指向对象的指针。使用delete操作符释放对象内存时会经历两个步骤：调用对象的析构函数；编译器调用operator delete函数释放内存空间（通常底层默认使用free实现）。

6. 扩张内存大小的区别
malloc：使用malloc分配内存后，发现内存不够用，那我们可以通过realloc函数来扩张内存大小，realloc会先判断当前申请的内存后面是否还有足够的内存空间进行扩张，如果有足够的空间，那么就会往后面继续申请空间，并返回原来的地址指针；否则realloc会在另外有足够大小的内存申请一块空间，并将当前内存空间里的内容拷贝到新的内存空间里，最后返回新的地址指针。
new：new没有扩张内存的机制。


