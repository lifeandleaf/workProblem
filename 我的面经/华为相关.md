### 手撕string类

[string类实现](./string.cpp)

### C++的define和const的区别，define的宏定义存放在那里

(1) 编译器处理方式不同  
define宏是在预处理阶段展开。    
const常量是编译运行阶段使用。   

(2) 类型和安全检查不同  
define宏没有类型，不做任何类型检查，仅仅是展开。    
const常量有具体的类型，在编译阶段会执行类型检查。   

(3) 存储方式不同    
define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。    
const常量会在内存中分配(可以是堆中也可以是栈中)。   

(4)const可以节省空间，避免不必要的内存分配      
const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而 #define定义的常量在内存中有若干个拷贝。

(5) 提高了效率  
编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高

### C++内存泄漏有哪些经典场景，如何避免？
1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数
2. 没有正确地清除嵌套的对象指针
3. 在释放对象数组时在delete中没有使用方括号(delete [])
4. 指向对象的指针数组不等同于对象数组   
对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间。指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。也就是说，数组的基本类型是指向对象的指针,此时，是用delete 还是delete [](array delete),并不重要，关键是指针并没有析构函数，必须用户自己调用delete语句。
5. 缺少拷贝构造函数
如果没有定义拷贝构造函数，系统根据自动生成的拷贝构造函数进行拷贝工作（浅拷贝），如果类内包含指针，那么两个类指向同一片内存，造成内存泄漏。
6. 缺少重载赋值运算符（理由类似上一条）
7. 返回野指针
8. 没有将基类的析构函数定义为虚函数

### STL相关vector，list

### B树和B+树

### 进程调度算法